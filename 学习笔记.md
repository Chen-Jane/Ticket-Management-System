# 学习笔记

## 一、程序准备

### <1>JDK环境配置

1.打开电脑控制面板->系统->高级设置。

2.在系统属性->高级中，点击右下角“环境变量”。

3.在系统变量中，点击“新建”，新建变量名为JAVA_HOME的变量，变量值为jdk的安装路径（直接复制黏贴地址）。

4.在系统变量中，寻找Path变量，点击“编辑”，新建“%JAVA_HOME%\bin"。（在jdk1.5以上不需再建CLASSPATH变量）

5.如何检验是否配置成功？

打开命令行（cmd），输入”java -version“(“-”前有空格)，显示jdk版本，再依次输入java和javac，出现一大堆说明，则环境变量配置成功。(“-”前有空格)

### <2>编译运行

1.编译

win+R打开命令行窗口，打入源程序文件所在储存盘（小写字母）并打”：“，如”d:”,回车后打入“cd”并空格，继续打入文件夹名称，如”Java”,回车并输入“javac  文件名”，如“javac  HelloWorld.java”,回车后编译在源程序地址处得到一个同名CLASS文件。

2.运行

如上编译后，输入”java java类名“如”java HelloWorld”,回车即可运行。

![](E:\Promgram\pictures\学习笔记\图片 6.png)

## 二、基础知识

### <1>常见DOS命令

![](E:\Promgram\pictures\学习笔记\图片 3.png)

### <2>三种变量

成员变量可以默认初始化，局部变量除形参外**必须**显式初始化，否则不可访问。

<img src="E:\Promgram\pictures\学习笔记\图片 5.png" style="zoom:150%;" />

### <3>命名规范

final:在变量定义前加上final，变量变为常量，不可再变化。****

![](E:\Promgram\pictures\学习笔记\图片 4.png)

## 三、主要知识

### <1>基本数据类型

基本数据类型的变量内存中存放其值，引用类型的变量里面存放的是地址，类似于指针。

![基本数据类型](E:\Promgram\pictures\学习笔记\基本数据类型.jpg)

#### **1.整型变量**

byte上限为127，short上限大约为3万，int 上限约为21亿

![3](E:\Promgram\pictures\学习笔记\3.jpg)

#### **2.浮点数**

不要使用浮点数进行比较和精确计算！需要比较可用BigDecimal类；java.math包中有两个有用的类：BigInteger和BigDecimal，前者实现任意精度的整数运算，后者实现任意精度的浮点运算；使用时应在最开头“import java.math .*;"。

![float ](E:\Promgram\pictures\学习笔记\float .jpg)

#### **3.字符型**

![字符 ](E:\Promgram\pictures\学习笔记\字符 .jpg)

#### **4.布尔型**

![布尔 ](E:\Promgram\pictures\学习笔记\布尔 .jpg)

### <2>运算符

![运算符](E:\Promgram\pictures\学习笔记\运算符.jpg)

#### 1.算术运算符

整数运算：若有long则结果为long,否则为int;

浮点运算：只有两个都为float才为float,否则为double;

取模运算：操作数可以为浮点数，但一般是整数，结果为余数，结果符号与左边操作数相同。

自增自减：a++代表先使用a再让a加一，++a代表先让a加一再使用，a--与--a同理。

注意赋值时考虑运算结果的类型是否会造成溢出，float可以接受long。

#### 2.赋值及其拓展运算符

+=、-=、*=、/=、%=，其中a+=b相当于a=a+b;注意：先算等号右边，那是一个整体。

#### 3.关系运算符

![关系 ](E:\Promgram\pictures\学习笔记\关系 .jpg)

#### 4.逻辑运算符

操作数与结果都是boolean类型，只有true 和false,没有0与非0数值。

<img src="E:\Promgram\pictures\学习笔记\逻辑.jpg" alt="逻辑" style="zoom:150%;" />

#### 5.位运算符

<img src="E:\Promgram\pictures\学习笔记\位运算.jpg" alt="位运算" style="zoom:150%;" />

#### 6.字符串连接符

只要+两侧有一个为字符串（用“ ”括起），系统将把另一个转为字符串再进行运算；

注意：是字符串且要两两计算，如果是字符与整型，将字符转为其Unicode的数值再进行运算，结果为整型。

#### 7.条件运算符

x?y:z  其中x为boolean类型表达式，若结果为true，整个表达式结果为y,否则为z;

#### 8.运算符优先级

算术运算符>关系运算符>逻辑运算符  逻辑非>逻辑与>逻辑或  优先小括号

<img src="E:\Promgram\pictures\学习笔记\优先级.jpg" alt="优先级" style="zoom:150%;" />

### <3>类型转换

#### 1.自动类型转化x

容量小的可以像容量大的转化（不是字节数),但long向float或double、int向float转换可能有精度的损失

特例：整型常量可以直接赋值给byte、short、char等类型变量，只要不超出其表述范围。

<img src="E:\Promgram\pictures\学习笔记\自动.jpg" alt="自动" style="zoom: 150%;" />

#### 2.强制类型转换

（类型）操作数，如（int)a,可能造成精度损失与信息丢失。

注意：当运算结果对于运算结果类型（不是被赋值的变量类型）可能发生溢出时，先将其中一个强制转换再运算，也需考虑被赋值的变量类型。

### <4>控制语句

#### 1.顺序结构

先执行A，再执行B的逻辑。

#### 2.选择结构

##### 单选择

两个判断结果执行的语句中一个为空。if ( 布尔表达式 ) { 语句块 }；

掷骰子游戏a=(int)(6*math.random()+1),产生[1,6]之间的随机数。

![单选择](E:\Promgram\pictures\学习笔记\单选择.jpg)

##### 双选择

if ( 布尔表达式 ) {语句块}  else{ 语句块 };

##### 多选择

if ( 布尔表达式 ) { 语句块 } else { if ( 布尔表达式) else { 语句块 } };

**switch语句**

![Switch](E:\Promgram\pictures\学习笔记\Switch.jpg)

#### 3.循环结构

当型：先判断再执行，当符合条件时执行循环体。while ( 布尔表达式 ) { 循环体 };

直到型：先执行再判断，直到不符合条件则跳出循环。do { 循环体 }while (布尔表达式)；

**for循环**

for( 1.初始表达式；2.布尔表达式；4.迭代因子){3. 循环体；} 如：for(int i=0; i<100;i++)

注意：在for语句里进行初始化的变量作用域只在for循环。

注意：System.out.print();执行结束后不换行，System.out.println();执行后自动换行。

##### 控制循环结构

break：直接使用只跳出当前内循环，若想跳出外层循环，需要在break后加一个标签，同时在外层循环前标识。如outer: for( ){ for( ){ break outer; } }(外循环前需带冒号)标签只能在循环语句前才可用。

continue:忽略本次循环剩下语句，接着开始下次循环，不会结束循环。若加标签，则表示结束所辨识的循环的当次循环，同样标签应放在外循环前，即此时跳出内循环并进入下一次外循环。

outer:for(int i=101;i<150;i++) {
			for(int m=2;m<i/2;m++) {
				if(i%m==0) {
					continue outer;
				}
			}
			System.out.print(i+" ");
		}

### <5>方法(Method)

#### 1.概念形式

方法就是一段用来完成特定功能的代码片段，类似于其他语言的函数。

[修饰符1 修饰符2 ……]   返回值类型   方法名（形式参数列表）{ Java语句；}

return有两个作用：结束方法和返回数值。**方法只能在类里面定义**

#### 2.重载(Overload)

名字相同，但是实际是不同的方法；**参数个数、参数 类型、参数顺序**不同可构成重载，但只有**返回值**不同、只有**参数名称**不同，不构成重载；

#### 3.调用

方法名称前有static修饰，可以直接调用，否则需要新建一个对象，如下：

public class TestMethod {
	public static void main(String[] args) {
		//通过对象调用方法
		TestMethod tm = new TestMethod();
		int c=tm.add(30,40,50);
		System.out.println(c);
	}
	int add(int a,int b,int c) {
		int sum=a+b+c;
		return sum;
	}

}

#### 4.递归

本质就是自己调用自己，需要定义递归头，即什么时候不调用自身，也就是递归的结束条件；还有递归提，即什么时候调用自身。

注意：任何递归可用循环代替，清晰但耗时远远长于循环，不推荐使用。

获得当前时间：long a=System.currentTimeMillis();

### <6>面向对象(object)

将实物抽象为类，以类为模板，运行形成多个对象，也叫实例。类是对象的模板，对象是类的实例。

#### 1.类class

**类 = 属性（成员变量）+ 方法 +构造器**。

定义属性：[修饰符] 属性类型 属性名 = [默认值] ;   对象的属性与方法调用用“."连接即可使用。

定义对象：类名  引用变量 = new 类名（）；类名（）调用该类的构造方法，即 类名（）{ }

一个java源文件里面可以定义多个类,但由public修饰的类只能有一个，main方法是程序的入口。

##### 构造方法（构造器）

方法名称和类名必须保持一致，通过new调用，不能使用return返回某个值。可用于创建这个类的对象，无参的构造方法可以由系统自动构建，若已定义一个重载方法则系统不会构建无参方法。构造方法的第一句总是super();但可以不写。**若方法构造中形参名与属性名相同时，需要使用 this 关键字区分属性与形参。**

#### 2.内存分析

##### 栈（stack）：一段连续内存，不可被多个线程共享，每个方法调用时会创建一个栈帧，先进后出

##### 堆（leap）：JVM（Java虚拟机）只有一个堆，用于存储创建好的对象和数组（数组也是对象），不连续						的内存空间，被所有线程共享。

##### 方法区（静态区）：实际也是堆，只是用来存储类、常量相关的永远不变或唯一的内容。

![image-20200330125453749](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20200330125453749.png)

#### 3.构建对象与this

##### 构建对象

分配对象空间，并将对象成员变量初始化为0(数值)、false(布尔型)和空；

执行属性值的显式初始化；//对象已经创建好

执行构造方法(若使用this表示当前对象)；

返回对象的地址给相关的变量。

定义对象：**类名 引用变量 = new 构造方法（类名（））；**实际上，引用变量里面只是存储了对象的地址，类似指针，真正的对象及其数据一直在堆里面。

##### this用法

this的本质是“**创建好的对象的地址**”，在构造方法中指“当前对象”，this不可以用在**static**方法里(staticb不属于对象)。

**避免二义性**：普通方法中this指向调用该方法的对象(对象的一个成员直接调用另一个成员可以省略this)，构造方法中指正要初始化的对象。

**调用重载的构造方法**：用this代替方法名来调用方法，必须位于构造方法的**第一句**，且只可在构造方法使用

#### 4.static关键字

static修饰的成员变量和方法，从属于类；普通变量和方法从属于对象。后者只可以通过实例调用，前者还可以通过类调用。调用语法：**类.类变量/方法**    **实例.实例变量/方法**。静态方法里面不能调用非静态方法，反之可以。

#### 5.参数传值机制

基本数据类型：传递参数的副本(copy)，基本不会影响原件。

引用类型：传递的仍是值的副本，但引用类型的值是“对象的地址”，改变副本指向地址对象的值，也使对象的值发生了改变。